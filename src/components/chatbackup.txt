import React, { useState, useCallback, useEffect, useMemo, useRef } from 'react'
import { StyleSheet, View, StatusBar, TouchableOpacity, Text, Image, FlatList } from 'react-native'
import { GiftedChat, IMessage, Bubble, InputToolbar, Send } from 'react-native-gifted-chat'
import { useSafeAreaInsets } from 'react-native-safe-area-context'
import { useNavigation } from '@react-navigation/native'
import DatePicker from 'react-native-date-picker'
import Feather from 'react-native-vector-icons/Feather'
import MaterialIcons from 'react-native-vector-icons/MaterialIcons'
import { Responsive } from '../utilities/Responsive'
import { Colors } from '../utilities/AppTheme'
import GradientBackground from '../components/GradientBackground'
import { startAiChat, fetchAllMovies } from '../services/MovieAiService'

const STEPS = {
  AI_DISCOVERY: 'AI_DISCOVERY', // New AI Step
  DATE: 'DATE',
  THEATER: 'THEATER',
  TIME: 'TIME',
  SEATS: 'SEATS',
  CONFIRM: 'CONFIRM'
}

const ChatScreen = ({ route }: any) => {
  const insets = useSafeAreaInsets()
  const navigation = useNavigation<any>()
  const [messages, setMessages] = useState<IMessage[]>([])
  const [isTyping, setIsTyping] = useState(false)
  const [showDatePicker, setShowDatePicker] = useState(false)
  const [selectedDate, setSelectedDate] = useState(new Date())
  const chatSessionRef = useRef<any>(null)
  const initRef = useRef(false)
  const lastPromptedMovieIdRef = useRef<string | null>(null)
  const [allMovies, setAllMovies] = useState<any[]>([])
  const [moviesLoading, setMoviesLoading] = useState(false)
  const CUSTOM_HEADER_HEIGHT = 50;
  const totalOffset = insets.top + Responsive.spacing[25] + CUSTOM_HEADER_HEIGHT;


  const [bookingState, setBookingState] = useState<any>({
    movieId: route?.params?.movieId || null,
    movieName: route?.params?.movieName || null,
    step: route?.params?.movieId ? STEPS.DATE : STEPS.AI_DISCOVERY,
    selectedDate: null,
    selectedTime: null,
    selectedTheater: null,
    selectedSeats: [],
    totalPrice: 0,
  })
  const botUser = useMemo(() => ({
    _id: 2,
    name: 'MovieBot',
    avatar: require('../assets/images/BotChat.png'),
  }), [])

  const appendBotMessage = useCallback((text: string, extra?: Partial<IMessage>) => {
    const botMsg: IMessage = {
      _id: Math.round(Math.random() * 1000000),
      text,
      createdAt: new Date(),
      user: botUser,
      ...(extra || {}),
    }
    setMessages(prev => GiftedChat.append(prev, [botMsg]))
  }, [botUser])

  const appendUserMessage = useCallback((text: string) => {
    const userMsg: IMessage = {
      _id: Math.round(Math.random() * 1000000),
      text,
      createdAt: new Date(),
      user: { _id: 1 },
    }
    setMessages(prev => GiftedChat.append(prev, [userMsg]))
  }, [])

  const ensureAiSession = useCallback(async () => {
    if (!chatSessionRef.current) {
      chatSessionRef.current = await startAiChat()
    }
    return chatSessionRef.current
  }, [])

  const ensureAllMovies = useCallback(async () => {
    if (allMovies.length > 0 || moviesLoading) return allMovies
    setMoviesLoading(true)
    try {
      const movies = await fetchAllMovies()
      setAllMovies(movies)
      return movies
    } catch (error) {
      console.error('Fetch movies error:', error)
      appendBotMessage('Sorry, I could not load movies right now. Please try again.')
      return []
    } finally {
      setMoviesLoading(false)
    }
  }, [allMovies, moviesLoading, appendBotMessage])

  const sendDiscoveryGreeting = useCallback(() => {
    appendBotMessage("Hello! I'm MovieBot ðŸŽ¬. I can help you find movies or book tickets. What would you like to do?", {
      quickReplies: {
        type: 'radio',
        keepIt: true,
        values: [
          { title: 'ðŸŽ¬ Show Movie List', value: 'list_movies' },
          { title: 'ðŸŽ­ Browse by Genre', value: 'list_genres' }
        ]
      }
    })
  }, [appendBotMessage])

  const sendMovieList = useCallback((movies: any[], heading?: string) => {
    if (heading) {
      appendBotMessage(heading)
    }
    const listMsg = {
      _id: Math.round(Math.random() * 1000000),
      text: '',
      createdAt: new Date(),
      user: botUser,
      custom: {
        type: 'movie_list',
        movies,
      },
    } as any
    setMessages(prev => GiftedChat.append(prev, [listMsg]))
  }, [appendBotMessage, botUser])

  const startBookingForMovie = useCallback((movie: any) => {
    setBookingState({
      movieId: movie.id,
      movieName: movie.title,
      step: STEPS.DATE,
      selectedDate: null,
      selectedTime: null,
      selectedTheater: null,
      selectedSeats: [],
      totalPrice: 0,
    })
    lastPromptedMovieIdRef.current = movie.id
    appendBotMessage(`You selected "${movie.title}". Would you like to book this movie?`, {
      quickReplies: {
        type: 'radio',
        keepIt: true,
        values: [
          { title: 'âœ… Yes, book it', value: 'book_movie' },
          { title: 'âŒ Not now', value: 'cancel_booking' }
        ]
      }
    })
  }, [appendBotMessage])

  const handleAiDiscovery = useCallback(async (userText: string) => {
    setIsTyping(true)
    try {
      const session = await ensureAiSession()
      const result = await session.sendMessage(userText)
      const response = result?.response
      const functionCalls = typeof response?.functionCalls === 'function' ? response.functionCalls() : []

      if (functionCalls?.length) {
        const call = functionCalls[0]
        const name = call?.name
        const args = call?.args || {}
        if (name === 'fetchAllMovies') {
          const movies = await ensureAllMovies()
          if (movies.length) {
            sendMovieList(movies, 'Here are the available movies:')
          }
        } else if (name === 'fetchMoviesByGenre') {
          const genre = (args.genre || '').toString()
          const movies = await ensureAllMovies()
          const filtered = movies.filter(m => {
            if (!m.genre) return false
            if (Array.isArray(m.genre)) {
              return m.genre.some((g: string) => g.toLowerCase() === genre.toLowerCase())
            }
            return String(m.genre).toLowerCase() === genre.toLowerCase()
          })
          if (filtered.length) {
            sendMovieList(filtered, `Here are ${genre} movies:`)
          } else {
            appendBotMessage(`I couldn't find ${genre} movies. Try another genre or view all movies.`)
          }
        } else {
          appendBotMessage(response?.text?.() || 'I can help you find movies or book tickets. Try "Show movie list".')
        }
      } else {
        appendBotMessage(response?.text?.() || 'I can help you find movies or book tickets. Try "Show movie list".')
      }
    } catch (error) {
      console.error('AI error:', error)
      appendBotMessage('Sorry, I had trouble understanding that. Try "Show movie list" or "Browse by genre".')
    } finally {
      setIsTyping(false)
    }
  }, [appendBotMessage, ensureAiSession, ensureAllMovies, sendMovieList])

  useEffect(() => {
    const init = async () => {
      if (initRef.current) return
      initRef.current = true
      await ensureAiSession()
      if (bookingState.movieId) {
        lastPromptedMovieIdRef.current = bookingState.movieId
        appendBotMessage(`Great! You've selected "${bookingState.movieName}". Let's get you a ticket.\n\nðŸ“… Please select your preferred date:`, {
          quickReplies: {
            type: 'radio',
            keepIt: true,
            values: [{ title: 'ðŸ“… Select Date', value: 'select_date' }]
          }
        })
      } else {
        sendDiscoveryGreeting()
      }
    }
    init()
  }, [appendBotMessage, bookingState.movieId, bookingState.movieName, ensureAiSession, sendDiscoveryGreeting])
  // Reset booking state when new movie is selected
  useEffect(() => {
    if (route?.params?.movieId) {
      setBookingState({
        movieId: route.params.movieId,
        movieName: route.params.movieName,
        step: STEPS.DATE,
        selectedDate: null,
        selectedTime: null,
        selectedTheater: null,
        selectedSeats: [],
        totalPrice: 0,
      })
      if (route.params.movieId !== lastPromptedMovieIdRef.current) {
        lastPromptedMovieIdRef.current = route.params.movieId
        appendBotMessage(`Great! You've selected "${route.params.movieName}". Let's get you a ticket.\n\nðŸ“… Please select your preferred date:`, {
          quickReplies: {
            type: 'radio',
            keepIt: true,
            values: [{ title: 'ðŸ“… Select Date', value: 'select_date' }]
          }
        })
      }
    }
  }, [appendBotMessage, route?.params?.movieId, route?.params?.movieName])

  useEffect(() => {
    if (route?.params?.selectedTheater) {
      handleTheaterReturn(route.params.selectedTheater, route.params.selectedTime)
    }
    if (route?.params?.selectedSeats) {
      handleSeatsReturn(route.params.selectedSeats)
    }
  }, [route?.params])

  const handleTheaterReturn = (theater: string, time: string) => {
    const userMsg: IMessage = {
      _id: Math.round(Math.random() * 1000000),
      text: `ðŸŽ­ ${theater} at ${time}`,
      createdAt: new Date(),
      user: { _id: 1 },
    }
    setMessages(prev => GiftedChat.append(prev, [userMsg]))

    setTimeout(() => {
      const botMsg: IMessage = {
        _id: Math.round(Math.random() * 1000000),
        text: `Perfect! ${theater} at ${time}\n\nNow let's select your seats:`,
        createdAt: new Date(),
        user: { _id: 2, name: 'MovieBot', avatar: require('../assets/images/BotChat.png') },
        quickReplies: {
          type: 'radio',
          keepIt: true,
          values: [{ title: 'ðŸª‘ Select Seats', value: 'select_seats' }]
        }
      }
      setMessages(prev => GiftedChat.append(prev, [botMsg]))
      setBookingState(prev => ({ ...prev, selectedTheater: theater, selectedTime: time, step: STEPS.SEATS }))
    }, 500)
  }

  const handleSeatsReturn = (seats: string[]) => {
    const totalPrice = seats.length * 250
    const userMsg: IMessage = {
      _id: Math.round(Math.random() * 1000000),
      text: `ðŸª‘ ${seats.length} seats: ${seats.join(', ')}`,
      createdAt: new Date(),
      user: { _id: 1 },
    }
    setMessages(prev => GiftedChat.append(prev, [userMsg]))

    setTimeout(() => {
      const summary = `ðŸ“‹ Booking Summary\n\nðŸŽ¬ ${bookingState.movieName}\nðŸ“… ${bookingState.selectedDate}\nðŸŽ­ ${bookingState.selectedTheater}\nâ° ${bookingState.selectedTime}\nðŸª‘ ${seats.join(', ')}\nðŸ’° â‚¹${totalPrice}\n\nReady to proceed?`
      const botMsg: IMessage = {
        _id: Math.round(Math.random() * 1000000),
        text: summary,
        createdAt: new Date(),
        user: { _id: 2, name: 'MovieBot', avatar: require('../assets/images/BotChat.png') },
        quickReplies: {
          type: 'radio',
          keepIt: true,
          values: [
            { title: 'ðŸ’³ Proceed to Payment', value: 'proceed_payment' },
            { title: 'ðŸ”„ Modify', value: 'modify' }
          ]
        }
      }
      setMessages(prev => GiftedChat.append(prev, [botMsg]))
      setBookingState(prev => ({ ...prev, selectedSeats: seats, totalPrice, step: STEPS.CONFIRM }))
    }, 500)
  }

  const handleDateConfirm = (date: Date) => {
    setShowDatePicker(false)
    const day = String(date.getDate()).padStart(2, '0')
    const month = String(date.getMonth() + 1).padStart(2, '0')
    const year = date.getFullYear()
    const storedFormat = `${day}/${month}/${year}`

    // Display format: Monday, February 16
    const displayFormat = date.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })

    const userMsg: IMessage = {
      _id: Math.round(Math.random() * 1000000),
      text: `ðŸ“… ${displayFormat}`,
      createdAt: new Date(),
      user: { _id: 1 },
    }
    setMessages(prev => GiftedChat.append(prev, [userMsg]))

    setTimeout(() => {
      const botMsg: IMessage = {
        _id: Math.round(Math.random() * 1000000),
        text: `Perfect! Now select theater for ${displayFormat}:`,
        createdAt: new Date(),
        user: { _id: 2, name: 'MovieBot', avatar: require('../assets/images/BotChat.png') },
        quickReplies: {
          type: 'radio',
          keepIt: true,
          values: [{ title: 'ðŸŽ­ Select Theater', value: 'select_theater' }]
        }
      }
      setMessages(prev => GiftedChat.append(prev, [botMsg]))
      setBookingState(prev => ({ ...prev, selectedDate: storedFormat, step: STEPS.THEATER }))
    }, 500)
  }

  const onQuickReply = useCallback((quickReply: any) => {
    const value = quickReply[0]?.value || ''
    const title = quickReply[0]?.title || ''

    appendUserMessage(title)

    if (value === 'select_date') {
      setShowDatePicker(true)
    } else if (value === 'list_movies') {
      ensureAllMovies().then(movies => {
        if (movies.length) {
          sendMovieList(movies, 'Here are the available movies:')
        }
      })
    } else if (value === 'list_genres') {
      ensureAllMovies().then((movies) => {
        const set = new Set<string>()
        movies.forEach(m => {
          if (!m.genre) return
          if (Array.isArray(m.genre)) {
            m.genre.forEach((g: string) => set.add(String(g)))
          } else {
            set.add(String(m.genre))
          }
        })
        const nextGenres = Array.from(set).slice(0, 8)
        if (!nextGenres.length) {
          appendBotMessage('No genres available right now. Try "Show Movie List".')
          return
        }
        appendBotMessage('Pick a genre:', {
          quickReplies: {
            type: 'radio',
            keepIt: true,
            values: nextGenres.map(g => ({ title: `ðŸŽ­ ${g}`, value: `genre:${g}` }))
          }
        })
      })
    } else if (value.startsWith('genre:')) {
      const genre = value.replace('genre:', '')
      ensureAllMovies().then(movies => {
        const filtered = movies.filter(m => {
          if (!m.genre) return false
          if (Array.isArray(m.genre)) {
            return m.genre.some((g: string) => String(g).toLowerCase() === genre.toLowerCase())
          }
          return String(m.genre).toLowerCase() === genre.toLowerCase()
        })
        if (filtered.length) {
          sendMovieList(filtered, `Here are ${genre} movies:`)
        } else {
          appendBotMessage(`No movies found for ${genre}. Try another genre.`)
        }
      })
    } else if (value === 'book_movie') {
      appendBotMessage(`Great! Let's pick a date.`, {
        quickReplies: {
          type: 'radio',
          keepIt: true,
          values: [{ title: 'ðŸ“… Select Date', value: 'select_date' }]
        }
      })
    } else if (value === 'select_theater') {
      if (!bookingState.selectedDate) {
        showError('Please select a date first')
        return
      }
      navigation.navigate('Home', {
        screen: 'TheaterSelection',
        params: { movieName: bookingState.movieName, date: bookingState.selectedDate, returnToChat: true }
      })
    } else if (value === 'select_seats') {
      if (!bookingState.selectedTheater) {
        showError('Please select theater first')
        return
      }
      navigation.navigate('Home', {
        screen: 'SeatSelection',
        params: {
          movieName: bookingState.movieName,
          theater: bookingState.selectedTheater,
          date: bookingState.selectedDate,
          time: bookingState.selectedTime,
          returnToChat: true
        }
      })
    } else if (value === 'proceed_payment') {
      setTimeout(() => {
        navigation.navigate('Home', {
          screen: 'Payment',
          params: {
            bookingDetails: {
              movieId: bookingState.movieId,
              movieName: bookingState.movieName,
              date: bookingState.selectedDate,
              theater: bookingState.selectedTheater,
              time: bookingState.selectedTime,
              seats: bookingState.selectedSeats,
              totalPrice: bookingState.totalPrice
            }
          }
        })
      }, 500)
      const botMsg: IMessage = {
        _id: Math.round(Math.random() * 1000000),
        text: 'âœ… Redirecting to payment...',
        createdAt: new Date(),
        user: { _id: 2, name: 'MovieBot', avatar: require('../assets/images/BotChat.png') },
      }
      setMessages(prev => GiftedChat.append(prev, [botMsg]))
    } else if (value === 'modify') {
      const botMsg: IMessage = {
        _id: Math.round(Math.random() * 1000000),
        text: 'What would you like to modify?',
        createdAt: new Date(),
        user: { _id: 2, name: 'MovieBot', avatar: require('../assets/images/BotChat.png') },
        quickReplies: {
          type: 'radio',
          keepIt: true,
          values: [
            { title: 'ðŸ“… Date', value: 'select_date' },
            { title: 'ðŸŽ­ Theater', value: 'select_theater' },
            { title: 'ðŸª‘ Seats', value: 'select_seats' }
          ]
        }
      }
      setMessages(prev => GiftedChat.append(prev, [botMsg]))
    } else if (value === 'cancel_booking') {
      setBookingState({
        movieId: null,
        movieName: null,
        step: STEPS.AI_DISCOVERY,
        selectedDate: null,
        selectedTime: null,
        selectedTheater: null,
        selectedSeats: [],
        totalPrice: 0,
      })
      appendBotMessage('No problem. If you want to browse again, choose an option below.', {
        quickReplies: {
          type: 'radio',
          keepIt: true,
          values: [
            { title: 'ðŸŽ¬ Show Movie List', value: 'list_movies' },
            { title: 'ðŸŽ­ Browse by Genre', value: 'list_genres' }
          ]
        }
      })
    }
  }, [appendBotMessage, appendUserMessage, bookingState, ensureAllMovies, sendMovieList])

  const showError = (msg: string) => {
    const botMsg: IMessage = {
      _id: Math.round(Math.random() * 1000000),
      text: `âŒ ${msg}`,
      createdAt: new Date(),
      user: { _id: 2, name: 'MovieBot', avatar: require('../assets/images/BotChat.png') },
    }
    setMessages(prev => GiftedChat.append(prev, [botMsg]))
  }

  const onSend = useCallback((newMessages: IMessage[] = []) => {
    setMessages(previousMessages => GiftedChat.append(previousMessages, newMessages))
    const userMessage = newMessages[0]?.text || ''
    if (bookingState.step === STEPS.AI_DISCOVERY && !bookingState.movieId) {
      handleAiDiscovery(userMessage)
      return
    }
    setIsTyping(true)
    setTimeout(() => {
      const { response, newState } = getBotResponse(userMessage.toLowerCase(), bookingState)
      if (newState) {
        setBookingState(newState)
      }
      const botMessage: IMessage = {
        _id: Math.round(Math.random() * 1000000),
        text: response,
        createdAt: new Date(),
        user: {
          _id: 2,
          name: 'MovieBot',
          avatar: require('../assets/appicon/MovieChatIcon.png'),
        },
      }
      setMessages(previousMessages => GiftedChat.append(previousMessages, [botMessage]))
      setIsTyping(false)
    }, 1500)
  }, [bookingState, handleAiDiscovery])

  const getBotResponse = (userMessage: string, state: any): { response: string; newState?: any } => {
    const { step, movieId, movieName } = state

    // Date selection
    if (step === STEPS.DATE && ['1', '2', '3', 'today', 'tomorrow'].some(k => userMessage.includes(k))) {
      const dates = ['Today', 'Tomorrow', 'Day After Tomorrow']
      const selectedDate = userMessage.includes('1') || userMessage.includes('today') ? dates[0] :
        userMessage.includes('2') || userMessage.includes('tomorrow') ? dates[1] : dates[2]

      return {
        response: `Perfect! ${selectedDate} it is! ðŸŽ¬\n\nâ° Select a showtime:\n\n1ï¸âƒ£ 10:00 AM\n2ï¸âƒ£ 01:00 PM\n3ï¸âƒ£ 04:00 PM\n4ï¸âƒ£ 07:00 PM\n5ï¸âƒ£ 10:00 PM`,
        newState: { ...state, selectedDate, step: STEPS.TIME }
      }
    }

    // Time selection
    if (step === STEPS.TIME && ['1', '2', '3', '4', '5'].some(k => userMessage.includes(k))) {
      const times = ['10:00 AM', '01:00 PM', '04:00 PM', '07:00 PM', '10:00 PM']
      const timeIndex = parseInt(userMessage.match(/[1-5]/)?.[0] || '1') - 1
      const selectedTime = times[timeIndex]

      return {
        response: `Great choice! ${selectedTime} â°\n\nðŸŽ­ Select a theater:\n\n1ï¸âƒ£ PVR Cinemas - Screen 1\n2ï¸âƒ£ INOX - Screen 2\n3ï¸âƒ£ Cinepolis - Screen 3`,
        newState: { ...state, selectedTime, step: STEPS.THEATER }
      }
    }

    // Theater selection
    if (step === STEPS.THEATER && ['1', '2', '3'].some(k => userMessage.includes(k))) {
      const theaters = ['PVR Cinemas - Screen 1', 'INOX - Screen 2', 'Cinepolis - Screen 3']
      const theaterIndex = parseInt(userMessage.match(/[1-3]/)?.[0] || '1') - 1
      const selectedTheater = theaters[theaterIndex]

      return {
        response: `Excellent! ${selectedTheater} ðŸŽ­\n\nHow many seats would you like to book?\n(Type a number between 1-10)`,
        newState: { ...state, selectedTheater, step: STEPS.SEATS }
      }
    }

    // Seat count selection
    if (step === STEPS.SEATS && /\d+/.test(userMessage)) {
      const seatCount = parseInt(userMessage.match(/\d+/)?.[0] || '1')
      if (seatCount > 0 && seatCount <= 10) {
        const pricePerSeat = 250
        const totalPrice = seatCount * pricePerSeat

        return {
          response: `Perfect! ${seatCount} seat(s) selected ðŸŽ«\n\nðŸ“ Booking Summary:\nâ€¢ Movie: ${movieName}\nâ€¢ Date: ${state.selectedDate}\nâ€¢ Time: ${state.selectedTime}\nâ€¢ Theater: ${state.selectedTheater}\nâ€¢ Seats: ${seatCount}\nâ€¢ Total: â‚¹${totalPrice}\n\nType 'confirm' to proceed to payment or 'cancel' to start over.`,
          newState: { ...state, selectedSeats: Array(seatCount).fill('A'), totalPrice, step: STEPS.CONFIRM }
        }
      }
    }

    // Confirmation
    if (step === STEPS.CONFIRM) {
      if (userMessage.includes('confirm')) {
        setTimeout(() => {
          console.log("State", state);

          navigation.navigate('Home', { screen: 'Payment', params: { bookingDetails: state } })
        }, 1000)
        return {
          response: `âœ… Booking confirmed! Redirecting to payment...`,
          newState: state
        }
      } else if (userMessage.includes('cancel')) {
        return {
          response: `Booking cancelled. How else can I help you?`,
          newState: { ...state, step: STEPS.DATE }
        }
      }
    }

    // Default responses
    if (userMessage.includes('movie') || userMessage.includes('film')) {
      return { response: 'Great! I can help you find movies. Here are some popular options:\n\nðŸŽ¬ Latest Releases\nðŸŽ­ Action Movies\nðŸ˜‚ Comedy Films\nðŸ’• Romance\n\nWhich genre interests you?' }
    } else if (userMessage.includes('book') || userMessage.includes('ticket')) {
      return { response: 'Perfect! I can help you book tickets. Please tell me which movie you\'d like to watch, or browse movies from the Home screen and tap "Book Now"!' }
    } else if (userMessage.includes('hello') || userMessage.includes('hi')) {
      return { response: 'Hello! Welcome to MovieBot! ðŸŽ¬\n\nI can help you with:\nâ€¢ Finding movies\nâ€¢ Checking showtimes\nâ€¢ Booking tickets\nâ€¢ Theater information\n\nWhat would you like to do?' }
    } else if (userMessage.includes('help')) {
      return { response: 'I\'m here to help! Here\'s what I can do:\n\nðŸŽ¬ Find Movies - Discover new releases and popular films\nâ° Showtimes - Check movie schedules\nðŸŽ« Book Tickets - Reserve your seats\nðŸ“ Theaters - Find nearby cinemas\n\nJust ask me anything!' }
    }

    return { response: 'I understand you\'re looking for movie-related assistance! I can help you with:\n\nâ€¢ Finding movies and showtimes\nâ€¢ Booking tickets\nâ€¢ Theater information\nâ€¢ Movie recommendations\n\nWhat specifically would you like to know?' }
  }

  const renderBubble = useCallback((props: any) => (
    <Bubble
      {...props}
      wrapperStyle={{
        right: {
          backgroundColor: Colors.primary,
          borderRadius: Responsive.radius[20],
          borderBottomRightRadius: 0,
          marginVertical: Responsive.spacing[2],
        },
        left: {
          backgroundColor: Colors.surface,
          borderRadius: Responsive.radius[20],
          borderBottomLeftRadius: 0,
          marginVertical: Responsive.spacing[2],
        },
      }}
      textStyle={{
        right: {
          color: Colors.text.inverse,
          fontSize: Responsive.fontSize[16],
        },
        left: {
          color: Colors.text.primary,
          fontSize: Responsive.fontSize[16],
        },
      }}
    />
  ), [])

  const renderInputToolbar = useCallback((props: any) => (
    <InputToolbar
      {...props}
      containerStyle={styles.inputToolbar}
      primaryStyle={styles.inputPrimary}
    />
  ), [])

  const renderSend = useCallback((props: any) => (
    <Send {...props}>
      <View style={styles.sendButton}>
        <MaterialIcons name="send" size={Responsive.fontSize[20]} color={Colors.text.inverse} />
      </View>
    </Send>
  ), [])

  const renderCustomView = useCallback((props: any) => {
    const { currentMessage } = props
    const message = currentMessage as any
    if (message?.custom?.type !== 'movie_list') return null
    const movies = message.custom.movies || []
    if (!movies.length) return null
    return (
      <View style={styles.movieListWrapper}>
        <FlatList
          data={movies}
          horizontal
          keyExtractor={(item) => item.id?.toString?.() || item.title}
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.movieListContainer}
          renderItem={({ item }) => (
            <TouchableOpacity
              style={styles.movieCard}
              onPress={() => startBookingForMovie(item)}
              activeOpacity={0.8}
            >
              <Image source={{ uri: item.image }} style={styles.movieCardImage} />
              <Text style={styles.movieCardTitle} numberOfLines={1}>{item.title}</Text>
              {item.genre ? (
                <Text style={styles.movieCardGenre} numberOfLines={1}>
                  {Array.isArray(item.genre) ? item.genre.join(', ') : item.genre}
                </Text>
              ) : null}
            </TouchableOpacity>
          )}
        />
      </View>
    )
  }, [startBookingForMovie])

  return (
    <GradientBackground>
      <View style={[styles.container,]}>
        <StatusBar barStyle="light-content" translucent backgroundColor={'transparent'} />

        {/* Header */}
        <View
          style={[styles.header, { paddingTop: insets.top + Responsive.spacing[15] }]}
        >
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
            activeOpacity={0.8}
          >
            <Feather name="arrow-left" size={Responsive.fontSize[24]} color={Colors.text.inverse} />
          </TouchableOpacity>

          <View style={styles.headerContent}>
            <View style={styles.headerTitle}>
              <Image
                source={require('../assets/images/BotChat.png')}
                style={{ width: Responsive.spacing[45], height: Responsive.spacing[45], }}
                resizeMode='contain'
              />
              <View style={styles.headerText}>
                <Text style={styles.chatTitle}>MovieBot</Text>
                <Text style={styles.chatSubtitle}>Online â€¢ Ready to help</Text>
              </View>
            </View>
          </View>
        </View>

        {/* Chat */}
        <GiftedChat
          messages={messages}
          onSend={onSend}
          onQuickReply={onQuickReply}
          user={{ _id: 1 }}
          renderBubble={renderBubble}
          renderCustomView={renderCustomView}
          renderInputToolbar={renderInputToolbar}
          renderSend={renderSend}
          textInputProps={{ placeholder: 'Enter a message' }}
          isTyping={isTyping}
          minInputToolbarHeight={60}
          keyboardAvoidingViewProps={{
            behavior: 'padding',
            keyboardVerticalOffset: totalOffset,
          }}
          listProps={{
            removeClippedSubviews: true,
            maxToRenderPerBatch: 10,
            windowSize: 10,
          }}
        />
      </View>
      <View style={{
        paddingBottom: insets.bottom + 10,
        backgroundColor: 'transparent'
      }} />

      <DatePicker
        modal
        open={showDatePicker}
        date={selectedDate}
        mode="date"
        minimumDate={new Date()}
        onConfirm={handleDateConfirm}
        onCancel={() => setShowDatePicker(false)}
        theme="dark"
      />
    </GradientBackground>
  )
}

export default ChatScreen

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: 'transparent',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: Responsive.spacing[20],
    paddingBottom: Responsive.spacing[15],
    backgroundColor: Colors.primary,
    elevation: 4,
    shadowColor: Colors.shadow,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
  },
  backButton: {
    padding: Responsive.padding[8],
    marginRight: Responsive.spacing[10],
  },
  headerContent: {
    flex: 1,
  },
  headerTitle: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  headerText: {
    marginLeft: Responsive.spacing[12],
  },
  chatTitle: {
    fontSize: Responsive.fontSize[18],
    fontWeight: 'bold',
    color: Colors.text.inverse,
  },
  chatSubtitle: {
    fontSize: Responsive.fontSize[12],
    color: Colors.text.inverse,
    opacity: 0.8,
    marginTop: Responsive.spacing[2],
  },
  inputToolbar: {
    backgroundColor: Colors.background,
    // borderTopColor: Colors.border.default,
    paddingHorizontal: Responsive.spacing[10],
    paddingVertical: Responsive.spacing[8],
    borderRadius: Responsive.radius[35],
  },
  inputPrimary: {
    backgroundColor: Colors.background,
    borderRadius: Responsive.radius[35],
    paddingHorizontal: Responsive.padding[10],
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 0.5,
    borderColor: Colors.border.default,
  },
  sendButton: {
    backgroundColor: Colors.primary,
    borderRadius: Responsive.radius[20],
    padding: Responsive.padding[10],
    justifyContent: 'center',
    alignItems: 'center',
  },
  movieListWrapper: {
    paddingVertical: Responsive.spacing[8],
  },
  movieListContainer: {
    paddingHorizontal: Responsive.spacing[6],
  },
  movieCard: {
    width: Responsive.size.wp(45),
    marginRight: Responsive.spacing[10],
    borderRadius: Responsive.radius[12],
    backgroundColor: Colors.surface,
    paddingBottom: Responsive.spacing[8],
    elevation: 2,
    shadowColor: Colors.shadow,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 3,
  },
  movieCardImage: {
    width: '100%',
    height: Responsive.size.hp(18),
    borderTopLeftRadius: Responsive.radius[12],
    borderTopRightRadius: Responsive.radius[12],
  },
  movieCardTitle: {
    fontSize: Responsive.fontSize[14],
    fontWeight: '600',
    color: Colors.text.primary,
    marginTop: Responsive.spacing[6],
    paddingHorizontal: Responsive.spacing[8],
  },
  movieCardGenre: {
    fontSize: Responsive.fontSize[11],
    color: Colors.text.secondary,
    marginTop: Responsive.spacing[2],
    paddingHorizontal: Responsive.spacing[8],
  },
})


import React, { useState, useCallback, useEffect, useMemo, useRef } from 'react'
import { StyleSheet, View, StatusBar, TouchableOpacity, Text, Image, FlatList } from 'react-native'
import { GiftedChat, IMessage, Bubble, InputToolbar, Send } from 'react-native-gifted-chat'
import { useSafeAreaInsets } from 'react-native-safe-area-context'
import { useNavigation } from '@react-navigation/native'
import DatePicker from 'react-native-date-picker'
import Feather from 'react-native-vector-icons/Feather'
import MaterialIcons from 'react-native-vector-icons/MaterialIcons'
import { Responsive } from '../utilities/Responsive'
import { Colors } from '../utilities/AppTheme'
import GradientBackground from '../components/GradientBackground'
import { startAiChat, fetchAllMovies } from '../services/MovieAiService'

const STEPS = {
  AI_DISCOVERY: 'AI_DISCOVERY', // New AI Step
  DATE: 'DATE',
  THEATER: 'THEATER',
  TIME: 'TIME',
  SEATS: 'SEATS',
  CONFIRM: 'CONFIRM'
}

const ChatScreen = ({ route }: any) => {
  const insets = useSafeAreaInsets()
  const navigation = useNavigation<any>()
  const [messages, setMessages] = useState<IMessage[]>([])
  const [isTyping, setIsTyping] = useState(false)
  const [showDatePicker, setShowDatePicker] = useState(false)
  const [selectedDate, setSelectedDate] = useState(new Date())
  const chatSessionRef = useRef<any>(null)
  const initRef = useRef(false)
  const lastPromptedMovieIdRef = useRef<string | null>(null)
  const [allMovies, setAllMovies] = useState<any[]>([])
  const [moviesLoading, setMoviesLoading] = useState(false)
  const CUSTOM_HEADER_HEIGHT = 50;
  const totalOffset = insets.top + Responsive.spacing[25] + CUSTOM_HEADER_HEIGHT;


  const [bookingState, setBookingState] = useState<any>({
    movieId: route?.params?.movieId || null,
    movieName: route?.params?.movieName || null,
    step: route?.params?.movieId ? STEPS.DATE : STEPS.AI_DISCOVERY,
    selectedDate: null,
    selectedTime: null,
    selectedTheater: null,
    selectedSeats: [],
    totalPrice: 0,
  })
  const botUser = useMemo(() => ({
    _id: 2,
    name: 'MovieBot',
    avatar: require('../assets/images/BotChat.png'),
  }), [])

  const appendBotMessage = useCallback((text: string, extra?: Partial<IMessage>) => {
    const botMsg: IMessage = {
      _id: Math.round(Math.random() * 1000000),
      text,
      createdAt: new Date(),
      user: botUser,
      ...(extra || {}),
    }
    setMessages(prev => GiftedChat.append(prev, [botMsg]))
  }, [botUser])

  const appendUserMessage = useCallback((text: string) => {
    const userMsg: IMessage = {
      _id: Math.round(Math.random() * 1000000),
      text,
      createdAt: new Date(),
      user: { _id: 1 },
    }
    setMessages(prev => GiftedChat.append(prev, [userMsg]))
  }, [])

  const ensureAiSession = useCallback(async () => {
    if (!chatSessionRef.current) {
      chatSessionRef.current = await startAiChat()
    }
    return chatSessionRef.current
  }, [])

  const ensureAllMovies = useCallback(async () => {
    if (allMovies.length > 0 || moviesLoading) return allMovies
    setMoviesLoading(true)
    try {
      const movies = await fetchAllMovies()
      setAllMovies(movies)
      return movies
    } catch (error) {
      console.error('Fetch movies error:', error)
      appendBotMessage('Sorry, I could not load movies right now. Please try again.')
      return []
    } finally {
      setMoviesLoading(false)
    }
  }, [allMovies, moviesLoading, appendBotMessage])

  const sendDiscoveryGreeting = useCallback(() => {
    appendBotMessage("Hello! I'm MovieBot ðŸŽ¬. I can help you find movies or book tickets. What would you like to do?", {
      quickReplies: {
        type: 'radio',
        keepIt: true,
        values: [
          { title: 'ðŸŽ¬ Show Movie List', value: 'list_movies' },
          { title: 'ðŸŽ­ Browse by Genre', value: 'list_genres' }
        ]
      }
    })
  }, [appendBotMessage])

  const sendMovieList = useCallback((movies: any[], heading?: string) => {
    if (heading) {
      appendBotMessage(heading)
    }
    const listMsg = {
      _id: Math.round(Math.random() * 1000000),
      text: '',
      createdAt: new Date(),
      user: botUser,
      custom: {
        type: 'movie_list',
        movies,
      },
    } as any
    setMessages(prev => GiftedChat.append(prev, [listMsg]))
  }, [appendBotMessage, botUser])

  const startBookingForMovie = useCallback((movie: any) => {
    setBookingState({
      movieId: movie.id,
      movieName: movie.title,
      step: STEPS.DATE,
      selectedDate: null,
      selectedTime: null,
      selectedTheater: null,
      selectedSeats: [],
      totalPrice: 0,
    })
    lastPromptedMovieIdRef.current = movie.id
    appendBotMessage(`You selected "${movie.title}". Would you like to book this movie?`, {
      quickReplies: {
        type: 'radio',
        keepIt: true,
        values: [
          { title: 'âœ… Yes, book it', value: 'book_movie' },
          { title: 'âŒ Not now', value: 'cancel_booking' }
        ]
      }
    })
  }, [appendBotMessage])

  const normalize = useCallback((text: string) => text.toLowerCase().trim(), [])

  const findMovieInText = useCallback((text: string, movies: any[]) => {
    const lower = normalize(text)
    // Prefer exact title match if quoted
    const quoted = lower.match(/"([^"]+)"/)?.[1]
    if (quoted) {
      const exact = movies.find(m => String(m.title).toLowerCase() === quoted)
      if (exact) return exact
    }
    // Fallback: title included in text
    return movies.find(m => lower.includes(String(m.title).toLowerCase()))
  }, [normalize])

  const findGenreInText = useCallback((text: string, movies: any[]) => {
    const lower = normalize(text)
    const set = new Set<string>()
    movies.forEach(m => {
      if (!m.genre) return
      if (Array.isArray(m.genre)) {
        m.genre.forEach((g: string) => set.add(String(g).toLowerCase()))
      } else {
        set.add(String(m.genre).toLowerCase())
      }
    })
    const genres = Array.from(set)
    return genres.find(g => lower.includes(g)) || null
  }, [normalize])

  const handleAiDiscovery = useCallback(async (userText: string) => {
    setIsTyping(true)
    try {
      const session = await ensureAiSession()
      const movies = await ensureAllMovies()
      const movieMatch = findMovieInText(userText, movies)
      const genreMatch = findGenreInText(userText, movies)

      const result = await session.sendMessage(userText)
      const response = result?.response
      const functionCalls = typeof response?.functionCalls === 'function' ? response.functionCalls() : []
      const aiText = response?.text?.()
      if (aiText) {
        appendBotMessage(aiText)
      }

      if (functionCalls?.length) {
        const call = functionCalls[0]
        const name = call?.name
        const args = call?.args || {}
        if (name === 'fetchAllMovies') {
          const movies = await ensureAllMovies()
          if (movies.length) {
            sendMovieList(movies, 'Here are the available movies:')
          }
        } else if (name === 'fetchMoviesByGenre') {
          const genre = (args.genre || '').toString()
          const movies = await ensureAllMovies()
          const filtered = movies.filter(m => {
            if (!m.genre) return false
            if (Array.isArray(m.genre)) {
              return m.genre.some((g: string) => g.toLowerCase() === genre.toLowerCase())
            }
            return String(m.genre).toLowerCase() === genre.toLowerCase()
          })
          if (filtered.length) {
            sendMovieList(filtered, `Here are ${genre} movies:`)
          } else {
            appendBotMessage(`I couldn't find ${genre} movies. Try another genre or view all movies.`)
          }
        } else {
          if (!aiText) {
            appendBotMessage('I can help you find movies or book tickets. Try "Show movie list".')
          }
        }
      } else {
        if (!aiText) {
          appendBotMessage('I can help you find movies or book tickets. Try "Show movie list".')
        }
      }

      if (movieMatch) {
        startBookingForMovie(movieMatch)
        return
      }
      if (genreMatch) {
        const filtered = movies.filter(m => {
          if (!m.genre) return false
          if (Array.isArray(m.genre)) {
            return m.genre.some((g: string) => String(g).toLowerCase() === genreMatch)
          }
          return String(m.genre).toLowerCase() === genreMatch
        })
        if (filtered.length) {
          sendMovieList(filtered, `Here are ${genreMatch} movies:`)
        } else {
          appendBotMessage(`No movies found for ${genreMatch}. Try another genre.`)
        }
      }
    } catch (error) {
      console.error('AI error:', error)
      appendBotMessage('Sorry, I had trouble understanding that. Try "Show movie list" or "Browse by genre".')
    } finally {
      setIsTyping(false)
    }
  }, [appendBotMessage, ensureAiSession, ensureAllMovies, findGenreInText, findMovieInText, sendMovieList, startBookingForMovie])

  useEffect(() => {
    const init = async () => {
      if (initRef.current) return
      initRef.current = true
      await ensureAiSession()
      if (bookingState.movieId) {
        lastPromptedMovieIdRef.current = bookingState.movieId
        appendBotMessage(`Great! You've selected "${bookingState.movieName}". Let's get you a ticket.\n\nðŸ“… Please select your preferred date:`, {
          quickReplies: {
            type: 'radio',
            keepIt: true,
            values: [{ title: 'ðŸ“… Select Date', value: 'select_date' }]
          }
        })
      } else {
        sendDiscoveryGreeting()
      }
    }
    init()
  }, [appendBotMessage, bookingState.movieId, bookingState.movieName, ensureAiSession, sendDiscoveryGreeting])
  // Reset booking state when new movie is selected
  useEffect(() => {
    if (route?.params?.movieId) {
      setBookingState({
        movieId: route.params.movieId,
        movieName: route.params.movieName,
        step: STEPS.DATE,
        selectedDate: null,
        selectedTime: null,
        selectedTheater: null,
        selectedSeats: [],
        totalPrice: 0,
      })
      if (route.params.movieId !== lastPromptedMovieIdRef.current) {
        lastPromptedMovieIdRef.current = route.params.movieId
        appendBotMessage(`Great! You've selected "${route.params.movieName}". Let's get you a ticket.\n\nðŸ“… Please select your preferred date:`, {
          quickReplies: {
            type: 'radio',
            keepIt: true,
            values: [{ title: 'ðŸ“… Select Date', value: 'select_date' }]
          }
        })
      }
    }
  }, [appendBotMessage, route?.params?.movieId, route?.params?.movieName])

  useEffect(() => {
    if (route?.params?.selectedTheater) {
      handleTheaterReturn(route.params.selectedTheater, route.params.selectedTime)
    }
    if (route?.params?.selectedSeats) {
      handleSeatsReturn(route.params.selectedSeats)
    }
  }, [route?.params])

  const handleTheaterReturn = (theater: string, time: string) => {
    const userMsg: IMessage = {
      _id: Math.round(Math.random() * 1000000),
      text: `ðŸŽ­ ${theater} at ${time}`,
      createdAt: new Date(),
      user: { _id: 1 },
    }
    setMessages(prev => GiftedChat.append(prev, [userMsg]))

    setTimeout(() => {
      const botMsg: IMessage = {
        _id: Math.round(Math.random() * 1000000),
        text: `Perfect! ${theater} at ${time}\n\nNow let's select your seats:`,
        createdAt: new Date(),
        user: { _id: 2, name: 'MovieBot', avatar: require('../assets/images/BotChat.png') },
        quickReplies: {
          type: 'radio',
          keepIt: true,
          values: [{ title: 'ðŸª‘ Select Seats', value: 'select_seats' }]
        }
      }
      setMessages(prev => GiftedChat.append(prev, [botMsg]))
      setBookingState(prev => ({ ...prev, selectedTheater: theater, selectedTime: time, step: STEPS.SEATS }))
    }, 500)
  }

  const handleSeatsReturn = (seats: string[]) => {
    const totalPrice = seats.length * 250
    const userMsg: IMessage = {
      _id: Math.round(Math.random() * 1000000),
      text: `ðŸª‘ ${seats.length} seats: ${seats.join(', ')}`,
      createdAt: new Date(),
      user: { _id: 1 },
    }
    setMessages(prev => GiftedChat.append(prev, [userMsg]))

    setTimeout(() => {
      const summary = `ðŸ“‹ Booking Summary\n\nðŸŽ¬ ${bookingState.movieName}\nðŸ“… ${bookingState.selectedDate}\nðŸŽ­ ${bookingState.selectedTheater}\nâ° ${bookingState.selectedTime}\nðŸª‘ ${seats.join(', ')}\nðŸ’° â‚¹${totalPrice}\n\nReady to proceed?`
      const botMsg: IMessage = {
        _id: Math.round(Math.random() * 1000000),
        text: summary,
        createdAt: new Date(),
        user: { _id: 2, name: 'MovieBot', avatar: require('../assets/images/BotChat.png') },
        quickReplies: {
          type: 'radio',
          keepIt: true,
          values: [
            { title: 'ðŸ’³ Proceed to Payment', value: 'proceed_payment' },
            { title: 'ðŸ”„ Modify', value: 'modify' }
          ]
        }
      }
      setMessages(prev => GiftedChat.append(prev, [botMsg]))
      setBookingState(prev => ({ ...prev, selectedSeats: seats, totalPrice, step: STEPS.CONFIRM }))
    }, 500)
  }

  const handleDateConfirm = (date: Date) => {
    setShowDatePicker(false)
    const day = String(date.getDate()).padStart(2, '0')
    const month = String(date.getMonth() + 1).padStart(2, '0')
    const year = date.getFullYear()
    const storedFormat = `${day}/${month}/${year}`

    // Display format: Monday, February 16
    const displayFormat = date.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })

    const userMsg: IMessage = {
      _id: Math.round(Math.random() * 1000000),
      text: `ðŸ“… ${displayFormat}`,
      createdAt: new Date(),
      user: { _id: 1 },
    }
    setMessages(prev => GiftedChat.append(prev, [userMsg]))

    setTimeout(() => {
      const botMsg: IMessage = {
        _id: Math.round(Math.random() * 1000000),
        text: `Perfect! Now select theater for ${displayFormat}:`,
        createdAt: new Date(),
        user: { _id: 2, name: 'MovieBot', avatar: require('../assets/images/BotChat.png') },
        quickReplies: {
          type: 'radio',
          keepIt: true,
          values: [{ title: 'ðŸŽ­ Select Theater', value: 'select_theater' }]
        }
      }
      setMessages(prev => GiftedChat.append(prev, [botMsg]))
      setBookingState(prev => ({ ...prev, selectedDate: storedFormat, step: STEPS.THEATER }))
    }, 500)
  }

  const onQuickReply = useCallback((quickReply: any) => {
    const value = quickReply[0]?.value || ''
    const title = quickReply[0]?.title || ''

    appendUserMessage(title)

    if (value === 'select_date') {
      setShowDatePicker(true)
    } else if (value === 'list_movies') {
      ensureAllMovies().then(movies => {
        if (movies.length) {
          sendMovieList(movies, 'Here are the available movies:')
        }
      })
    } else if (value === 'list_genres') {
      ensureAllMovies().then((movies) => {
        const set = new Set<string>()
        movies.forEach(m => {
          if (!m.genre) return
          if (Array.isArray(m.genre)) {
            m.genre.forEach((g: string) => set.add(String(g)))
          } else {
            set.add(String(m.genre))
          }
        })
        const nextGenres = Array.from(set).slice(0, 8)
        if (!nextGenres.length) {
          appendBotMessage('No genres available right now. Try "Show Movie List".')
          return
        }
        appendBotMessage('Pick a genre:', {
          quickReplies: {
            type: 'radio',
            keepIt: true,
            values: nextGenres.map(g => ({ title: `ðŸŽ­ ${g}`, value: `genre:${g}` }))
          }
        })
      })
    } else if (value.startsWith('genre:')) {
      const genre = value.replace('genre:', '')
      ensureAllMovies().then(movies => {
        const filtered = movies.filter(m => {
          if (!m.genre) return false
          if (Array.isArray(m.genre)) {
            return m.genre.some((g: string) => String(g).toLowerCase() === genre.toLowerCase())
          }
          return String(m.genre).toLowerCase() === genre.toLowerCase()
        })
        if (filtered.length) {
          sendMovieList(filtered, `Here are ${genre} movies:`)
        } else {
          appendBotMessage(`No movies found for ${genre}. Try another genre.`)
        }
      })
    } else if (value === 'book_movie') {
      appendBotMessage(`Great! Let's pick a date.`, {
        quickReplies: {
          type: 'radio',
          keepIt: true,
          values: [{ title: 'ðŸ“… Select Date', value: 'select_date' }]
        }
      })
    } else if (value === 'select_theater') {
      if (!bookingState.selectedDate) {
        showError('Please select a date first')
        return
      }
      navigation.navigate('Home', {
        screen: 'TheaterSelection',
        params: { movieName: bookingState.movieName, date: bookingState.selectedDate, returnToChat: true }
      })
    } else if (value === 'select_seats') {
      if (!bookingState.selectedTheater) {
        showError('Please select theater first')
        return
      }
      navigation.navigate('Home', {
        screen: 'SeatSelection',
        params: {
          movieName: bookingState.movieName,
          theater: bookingState.selectedTheater,
          date: bookingState.selectedDate,
          time: bookingState.selectedTime,
          returnToChat: true
        }
      })
    } else if (value === 'proceed_payment') {
      setTimeout(() => {
        navigation.navigate('Home', {
          screen: 'Payment',
          params: {
            bookingDetails: {
              movieId: bookingState.movieId,
              movieName: bookingState.movieName,
              date: bookingState.selectedDate,
              theater: bookingState.selectedTheater,
              time: bookingState.selectedTime,
              seats: bookingState.selectedSeats,
              totalPrice: bookingState.totalPrice
            }
          }
        })
      }, 500)
      const botMsg: IMessage = {
        _id: Math.round(Math.random() * 1000000),
        text: 'âœ… Redirecting to payment...',
        createdAt: new Date(),
        user: { _id: 2, name: 'MovieBot', avatar: require('../assets/images/BotChat.png') },
      }
      setMessages(prev => GiftedChat.append(prev, [botMsg]))
    } else if (value === 'modify') {
      const botMsg: IMessage = {
        _id: Math.round(Math.random() * 1000000),
        text: 'What would you like to modify?',
        createdAt: new Date(),
        user: { _id: 2, name: 'MovieBot', avatar: require('../assets/images/BotChat.png') },
        quickReplies: {
          type: 'radio',
          keepIt: true,
          values: [
            { title: 'ðŸ“… Date', value: 'select_date' },
            { title: 'ðŸŽ­ Theater', value: 'select_theater' },
            { title: 'ðŸª‘ Seats', value: 'select_seats' }
          ]
        }
      }
      setMessages(prev => GiftedChat.append(prev, [botMsg]))
    } else if (value === 'cancel_booking') {
      setBookingState({
        movieId: null,
        movieName: null,
        step: STEPS.AI_DISCOVERY,
        selectedDate: null,
        selectedTime: null,
        selectedTheater: null,
        selectedSeats: [],
        totalPrice: 0,
      })
      appendBotMessage('No problem. If you want to browse again, choose an option below.', {
        quickReplies: {
          type: 'radio',
          keepIt: true,
          values: [
            { title: 'ðŸŽ¬ Show Movie List', value: 'list_movies' },
            { title: 'ðŸŽ­ Browse by Genre', value: 'list_genres' }
          ]
        }
      })
    }
  }, [appendBotMessage, appendUserMessage, bookingState, ensureAllMovies, sendMovieList])

  const showError = (msg: string) => {
    const botMsg: IMessage = {
      _id: Math.round(Math.random() * 1000000),
      text: `âŒ ${msg}`,
      createdAt: new Date(),
      user: { _id: 2, name: 'MovieBot', avatar: require('../assets/images/BotChat.png') },
    }
    setMessages(prev => GiftedChat.append(prev, [botMsg]))
  }

  const onSend = useCallback((newMessages: IMessage[] = []) => {
    setMessages(previousMessages => GiftedChat.append(previousMessages, newMessages))
    const userMessage = newMessages[0]?.text || ''
    if (bookingState.step === STEPS.AI_DISCOVERY && !bookingState.movieId) {
      handleAiDiscovery(userMessage)
      return
    }
    setIsTyping(true)
    setTimeout(() => {
      const { response, newState } = getBotResponse(userMessage.toLowerCase(), bookingState)
      if (newState) {
        setBookingState(newState)
      }
      const botMessage: IMessage = {
        _id: Math.round(Math.random() * 1000000),
        text: response,
        createdAt: new Date(),
        user: {
          _id: 2,
          name: 'MovieBot',
          avatar: require('../assets/appicon/MovieChatIcon.png'),
        },
      }
      setMessages(previousMessages => GiftedChat.append(previousMessages, [botMessage]))
      setIsTyping(false)
    }, 1500)
  }, [bookingState, handleAiDiscovery])

  const getBotResponse = (userMessage: string, state: any): { response: string; newState?: any } => {
    const { step, movieId, movieName } = state

    // Date selection
    if (step === STEPS.DATE && ['1', '2', '3', 'today', 'tomorrow'].some(k => userMessage.includes(k))) {
      const dates = ['Today', 'Tomorrow', 'Day After Tomorrow']
      const selectedDate = userMessage.includes('1') || userMessage.includes('today') ? dates[0] :
        userMessage.includes('2') || userMessage.includes('tomorrow') ? dates[1] : dates[2]

      return {
        response: `Perfect! ${selectedDate} it is! ðŸŽ¬\n\nâ° Select a showtime:\n\n1ï¸âƒ£ 10:00 AM\n2ï¸âƒ£ 01:00 PM\n3ï¸âƒ£ 04:00 PM\n4ï¸âƒ£ 07:00 PM\n5ï¸âƒ£ 10:00 PM`,
        newState: { ...state, selectedDate, step: STEPS.TIME }
      }
    }

    // Time selection
    if (step === STEPS.TIME && ['1', '2', '3', '4', '5'].some(k => userMessage.includes(k))) {
      const times = ['10:00 AM', '01:00 PM', '04:00 PM', '07:00 PM', '10:00 PM']
      const timeIndex = parseInt(userMessage.match(/[1-5]/)?.[0] || '1') - 1
      const selectedTime = times[timeIndex]

      return {
        response: `Great choice! ${selectedTime} â°\n\nðŸŽ­ Select a theater:\n\n1ï¸âƒ£ PVR Cinemas - Screen 1\n2ï¸âƒ£ INOX - Screen 2\n3ï¸âƒ£ Cinepolis - Screen 3`,
        newState: { ...state, selectedTime, step: STEPS.THEATER }
      }
    }

    // Theater selection
    if (step === STEPS.THEATER && ['1', '2', '3'].some(k => userMessage.includes(k))) {
      const theaters = ['PVR Cinemas - Screen 1', 'INOX - Screen 2', 'Cinepolis - Screen 3']
      const theaterIndex = parseInt(userMessage.match(/[1-3]/)?.[0] || '1') - 1
      const selectedTheater = theaters[theaterIndex]

      return {
        response: `Excellent! ${selectedTheater} ðŸŽ­\n\nHow many seats would you like to book?\n(Type a number between 1-10)`,
        newState: { ...state, selectedTheater, step: STEPS.SEATS }
      }
    }

    // Seat count selection
    if (step === STEPS.SEATS && /\d+/.test(userMessage)) {
      const seatCount = parseInt(userMessage.match(/\d+/)?.[0] || '1')
      if (seatCount > 0 && seatCount <= 10) {
        const pricePerSeat = 250
        const totalPrice = seatCount * pricePerSeat

        return {
          response: `Perfect! ${seatCount} seat(s) selected ðŸŽ«\n\nðŸ“ Booking Summary:\nâ€¢ Movie: ${movieName}\nâ€¢ Date: ${state.selectedDate}\nâ€¢ Time: ${state.selectedTime}\nâ€¢ Theater: ${state.selectedTheater}\nâ€¢ Seats: ${seatCount}\nâ€¢ Total: â‚¹${totalPrice}\n\nType 'confirm' to proceed to payment or 'cancel' to start over.`,
          newState: { ...state, selectedSeats: Array(seatCount).fill('A'), totalPrice, step: STEPS.CONFIRM }
        }
      }
    }

    // Confirmation
    if (step === STEPS.CONFIRM) {
      if (userMessage.includes('confirm')) {
        setTimeout(() => {
          console.log("State", state);

          navigation.navigate('Home', { screen: 'Payment', params: { bookingDetails: state } })
        }, 1000)
        return {
          response: `âœ… Booking confirmed! Redirecting to payment...`,
          newState: state
        }
      } else if (userMessage.includes('cancel')) {
        return {
          response: `Booking cancelled. How else can I help you?`,
          newState: { ...state, step: STEPS.DATE }
        }
      }
    }

    // Default responses
    if (userMessage.includes('movie') || userMessage.includes('film')) {
      return { response: 'Great! I can help you find movies. Here are some popular options:\n\nðŸŽ¬ Latest Releases\nðŸŽ­ Action Movies\nðŸ˜‚ Comedy Films\nðŸ’• Romance\n\nWhich genre interests you?' }
    } else if (userMessage.includes('book') || userMessage.includes('ticket')) {
      return { response: 'Perfect! I can help you book tickets. Please tell me which movie you\'d like to watch, or browse movies from the Home screen and tap "Book Now"!' }
    } else if (userMessage.includes('hello') || userMessage.includes('hi')) {
      return { response: 'Hello! Welcome to MovieBot! ðŸŽ¬\n\nI can help you with:\nâ€¢ Finding movies\nâ€¢ Checking showtimes\nâ€¢ Booking tickets\nâ€¢ Theater information\n\nWhat would you like to do?' }
    } else if (userMessage.includes('help')) {
      return { response: 'I\'m here to help! Here\'s what I can do:\n\nðŸŽ¬ Find Movies - Discover new releases and popular films\nâ° Showtimes - Check movie schedules\nðŸŽ« Book Tickets - Reserve your seats\nðŸ“ Theaters - Find nearby cinemas\n\nJust ask me anything!' }
    }

    return { response: 'I understand you\'re looking for movie-related assistance! I can help you with:\n\nâ€¢ Finding movies and showtimes\nâ€¢ Booking tickets\nâ€¢ Theater information\nâ€¢ Movie recommendations\n\nWhat specifically would you like to know?' }
  }

  const renderBubble = useCallback((props: any) => (
    <Bubble
      {...props}
      wrapperStyle={{
        right: {
          backgroundColor: Colors.primary,
          borderRadius: Responsive.radius[20],
          borderBottomRightRadius: 0,
          marginVertical: Responsive.spacing[2],
        },
        left: {
          backgroundColor: Colors.surface,
          borderRadius: Responsive.radius[20],
          borderBottomLeftRadius: 0,
          marginVertical: Responsive.spacing[2],
        },
      }}
      textStyle={{
        right: {
          color: Colors.text.inverse,
          fontSize: Responsive.fontSize[16],
        },
        left: {
          color: Colors.text.primary,
          fontSize: Responsive.fontSize[16],
        },
      }}
    />
  ), [])

  const renderInputToolbar = useCallback((props: any) => (
    <InputToolbar
      {...props}
      containerStyle={styles.inputToolbar}
      primaryStyle={styles.inputPrimary}
    />
  ), [])

  const renderSend = useCallback((props: any) => (
    <Send {...props}>
      <View style={styles.sendButton}>
        <MaterialIcons name="send" size={Responsive.fontSize[20]} color={Colors.text.inverse} />
      </View>
    </Send>
  ), [])

  const renderCustomView = useCallback((props: any) => {
    const { currentMessage } = props
    const message = currentMessage as any
    if (message?.custom?.type !== 'movie_list') return null
    const movies = message.custom.movies || []
    if (!movies.length) return null
    return (
      <View style={styles.movieListWrapper}>
        <FlatList
          data={movies}
          horizontal
          keyExtractor={(item) => item.id?.toString?.() || item.title}
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.movieListContainer}
          renderItem={({ item }) => (
            <TouchableOpacity
              style={styles.movieCard}
              onPress={() => startBookingForMovie(item)}
              activeOpacity={0.8}
            >
              <Image source={{ uri: item.image }} style={styles.movieCardImage} />
              <Text style={styles.movieCardTitle} numberOfLines={1}>{item.title}</Text>
              {item.genre ? (
                <Text style={styles.movieCardGenre} numberOfLines={1}>
                  {Array.isArray(item.genre) ? item.genre.join(', ') : item.genre}
                </Text>
              ) : null}
            </TouchableOpacity>
          )}
        />
      </View>
    )
  }, [startBookingForMovie])

  return (
    <GradientBackground>
      <View style={[styles.container,]}>
        <StatusBar barStyle="light-content" translucent backgroundColor={'transparent'} />

        {/* Header */}
        <View
          style={[styles.header, { paddingTop: insets.top + Responsive.spacing[15] }]}
        >
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
            activeOpacity={0.8}
          >
            <Feather name="arrow-left" size={Responsive.fontSize[24]} color={Colors.text.inverse} />
          </TouchableOpacity>

          <View style={styles.headerContent}>
            <View style={styles.headerTitle}>
              <Image
                source={require('../assets/images/BotChat.png')}
                style={{ width: Responsive.spacing[45], height: Responsive.spacing[45], }}
                resizeMode='contain'
              />
              <View style={styles.headerText}>
                <Text style={styles.chatTitle}>MovieBot</Text>
                <Text style={styles.chatSubtitle}>Online â€¢ Ready to help</Text>
              </View>
            </View>
          </View>
        </View>

        {/* Chat */}
        <GiftedChat
          messages={messages}
          onSend={onSend}
          onQuickReply={onQuickReply}
          user={{ _id: 1 }}
          renderBubble={renderBubble}
          renderCustomView={renderCustomView}
          renderInputToolbar={renderInputToolbar}
          renderSend={renderSend}
          textInputProps={{ placeholder: 'Enter a message' }}
          isTyping={isTyping}
          minInputToolbarHeight={60}
          keyboardAvoidingViewProps={{
            behavior: 'padding',
            keyboardVerticalOffset: totalOffset,
          }}
          listProps={{
            removeClippedSubviews: true,
            maxToRenderPerBatch: 10,
            windowSize: 10,
          }}
        />
      </View>
      <View style={{
        paddingBottom: insets.bottom + 10,
        backgroundColor: 'transparent'
      }} />

      <DatePicker
        modal
        open={showDatePicker}
        date={selectedDate}
        mode="date"
        minimumDate={new Date()}
        onConfirm={handleDateConfirm}
        onCancel={() => setShowDatePicker(false)}
        theme="dark"
      />
    </GradientBackground>
  )
}

export default ChatScreen

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: 'transparent',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: Responsive.spacing[20],
    paddingBottom: Responsive.spacing[15],
    backgroundColor: Colors.primary,
    elevation: 4,
    shadowColor: Colors.shadow,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
  },
  backButton: {
    padding: Responsive.padding[8],
    marginRight: Responsive.spacing[10],
  },
  headerContent: {
    flex: 1,
  },
  headerTitle: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  headerText: {
    marginLeft: Responsive.spacing[12],
  },
  chatTitle: {
    fontSize: Responsive.fontSize[18],
    fontWeight: 'bold',
    color: Colors.text.inverse,
  },
  chatSubtitle: {
    fontSize: Responsive.fontSize[12],
    color: Colors.text.inverse,
    opacity: 0.8,
    marginTop: Responsive.spacing[2],
  },
  inputToolbar: {
    backgroundColor: Colors.background,
    // borderTopColor: Colors.border.default,
    paddingHorizontal: Responsive.spacing[10],
    paddingVertical: Responsive.spacing[8],
    borderRadius: Responsive.radius[35],
  },
  inputPrimary: {
    backgroundColor: Colors.background,
    borderRadius: Responsive.radius[35],
    paddingHorizontal: Responsive.padding[10],
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 0.5,
    borderColor: Colors.border.default,
  },
  sendButton: {
    backgroundColor: Colors.primary,
    borderRadius: Responsive.radius[20],
    padding: Responsive.padding[10],
    justifyContent: 'center',
    alignItems: 'center',
  },
  movieListWrapper: {
    paddingVertical: Responsive.spacing[8],
  },
  movieListContainer: {
    paddingHorizontal: Responsive.spacing[6],
  },
  movieCard: {
    width: Responsive.size.wp(45),
    marginRight: Responsive.spacing[10],
    borderRadius: Responsive.radius[12],
    backgroundColor: Colors.surface,
    paddingBottom: Responsive.spacing[8],
    elevation: 2,
    shadowColor: Colors.shadow,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 3,
  },
  movieCardImage: {
    width: '100%',
    height: Responsive.size.hp(18),
    borderTopLeftRadius: Responsive.radius[12],
    borderTopRightRadius: Responsive.radius[12],
  },
  movieCardTitle: {
    fontSize: Responsive.fontSize[14],
    fontWeight: '600',
    color: Colors.text.primary,
    marginTop: Responsive.spacing[6],
    paddingHorizontal: Responsive.spacing[8],
  },
  movieCardGenre: {
    fontSize: Responsive.fontSize[11],
    color: Colors.text.secondary,
    marginTop: Responsive.spacing[2],
    paddingHorizontal: Responsive.spacing[8],
  },
})
